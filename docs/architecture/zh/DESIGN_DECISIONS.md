[English](../en/DESIGN_DECISIONS.md) | [简体中文](DESIGN_DECISIONS.md)

---

# 设计决策

**文档类型**: 架构  
**目的**: 记录关键技术决策及其理由

---

## 存储架构

### 决策: 混合 SQLite + 文件系统

**背景**: 需要同时存储结构化元数据和大型二进制文件。

**考虑的替代方案**:
1. **纯文件系统**（v0.1-v0.2 方法）
   - 简单，人类可读
   - 查询慢（1000 个实验 5-10秒）
   
2. **纯 SQLite**
   - 查询快
   - 不适合大文件（100MB+ 模型）
   
3. **外部数据库**（PostgreSQL, MySQL）
   - 查询性能最佳
   - 需要服务器设置，用户复杂

**决策**: 混合（SQLite + 文件）

**理由**:
- SQLite: 快速查询，零设置，可移植
- 文件: 大型二进制自然存储，Git 友好
- 两全其美

**权衡**:
- ✅ 查询比纯文件快 100 倍
- ✅ 无需设置 vs 外部数据库
- ⚠️ 双写复杂性
- ⚠️ 单机限制（目标用例可接受）

---

## 内容去重

### 决策: 基于 SHA256 + 硬链接

**背景**: ML 模型经常共享预训练权重，消耗大量存储。

**考虑的替代方案**:
1. **无去重**
   - 简单
   - 100 个检查点 100GB
   
2. **Git-LFS**
   - 行业标准
   - 外部依赖，需要服务器
   
3. **压缩**（gzip, zstd）
   - 减小大小
   - CPU 成本，仍有冗余存储
   
4. **块级去重**（ZFS, btrfs）
   - 操作系统级别
   - 不可移植，需要特定文件系统

**决策**: 基于内容的去重 + 硬链接

**理由**:
- SHA256: 安全，快速，碰撞风险可忽略
- 硬链接: 零拷贝，操作系统支持
- 所有平台都可用（带回退到复制）

**权衡**:
- ✅ 50-90% 空间节省
- ✅ 哈希后零 CPU 开销
- ⚠️ 跨文件系统限制（同一驱动器/文件系统）
- ⚠️ Windows 需要管理员权限（回退到复制）

---

## API 框架

### 决策: FastAPI 而非 Flask/Django

**背景**: 需要支持异步的现代 API 框架。

**考虑的替代方案**:
1. **Flask**
   - 简单，广泛使用
   - 仅同步，手动文档，较慢
   
2. **Django + DRF**
   - 功能齐全
   - 笨重，固执己见，对于仅 API 过度
   
3. **aiohttp**
   - 纯异步
   - 较低级，更多样板代码

**决策**: FastAPI

**理由**:
- 自动生成 OpenAPI 文档（Swagger/ReDoc）
- 原生 async/await 支持
- Pydantic 验证（类型安全）
- 快速（与 Node.js/Go 相当）
- 现代 Python 3.8+ 特性

**权衡**:
- ✅ 最佳开发者体验
- ✅ 自动文档
- ⚠️ 较新（比 Flask 成熟度低）
- ⚠️ 异步模式学习曲线

---

## 前端框架

### 决策: React + Ant Design

**背景**: 需要现代、基于组件的 UI，具有专业外观。

**考虑的替代方案**:
1. **Vue.js**
   - 学习曲线更简单
   - 企业 UI 生态较小

2. **Angular**
   - 完整框架
   - 笨重，学习曲线陡峭

3. **Svelte**
   - 创新，快速
   - 生态较小

**决策**: React 18 + Ant Design 5

**理由**:
- React: 最大生态系统，复杂 UI 经过验证
- Ant Design: 企业级组件，内置国际化
- TypeScript: 类型安全，更好的重构
- Vite: 快速开发体验

**权衡**:
- ✅ 最佳生态和组件库
- ✅ 开箱即用的专业外观
- ⚠️ 包大小比 Svelte 大
- ⚠️ 比 Vue 更多样板代码

---

## 数据库选择

### 决策: SQLite 而非 PostgreSQL/MySQL

**背景**: 需要可查询的元数据存储。

**考虑的替代方案**:
1. **PostgreSQL**
   - 最佳性能
   - 需要服务器，复杂设置
   
2. **MySQL/MariaDB**
   - 良好性能
   - 需要服务器
   
3. **MongoDB**
   - 灵活 schema
   - 需要服务器，不同查询模型
   
4. **内存**（Redis, Memcached）
   - 最快
   - 不持久

**决策**: SQLite with WAL 模式

**理由**:
- 零设置: 单文件数据库
- 可移植: Python 可用的地方都能工作
- ACID: 事务安全
- 足够好: 处理 100k+ 实验
- 打包: 无外部依赖

**权衡**:
- ✅ 最适合单机、自托管
- ✅ 零配置
- ✅ 易于备份（复制一个文件）
- ⚠️ 不适合分布式系统
- ⚠️ 并发写限制（WAL 缓解）

---

## 版本控制策略

### 决策: 自动顺序版本（v1, v2, v3...）

**背景**: 需要简单、可预测的 ML 资产版本控制。

**考虑的替代方案**:
1. **语义化版本**（1.0.0, 1.1.0）
   - 软件行业标准
   - 对 ML 来说复杂（什么是主版本 vs 次版本？）
   
2. **Git 式哈希**
   - 唯一，分布式
   - 不用户友好
   
3. **时间戳**
   - 自动
   - 难以引用（"凌晨2点的版本"）
   
4. **用户定义**
   - 完全控制
   - 冲突风险，不一致

**决策**: 顺序整数 + 可选别名

**理由**:
- 简单: v1, v2, v3 易于理解
- 可预测: 无冲突
- 灵活: 别名用于语义含义（latest, production）
- 适合 ML: 实验是顺序的

**权衡**:
- ✅ 最简单的心智模型
- ✅ 无版本冲突
- ⚠️ 并行保存需要协调（通过锁处理）

---

## 桌面应用方法

### 决策: Tauri 而非 Electron

**背景**: 需要原生 Windows 桌面应用。

**考虑的替代方案**:
1. **Electron**
   - 最流行
   - 笨重（~100MB+ 应用大小）
   - 嵌入 Chromium
   
2. **Qt/PyQt**
   - 原生外观
   - 与 Web 不同的 UI 代码
   
3. **PWA**（渐进式 Web 应用）
   - 无需安装
   - 有限的操作系统集成

**决策**: Tauri

**理由**:
- 轻量: 3-5MB vs 100MB（Electron）
- 安全: Rust 后端，沙盒化
- 复用 Web UI: 同一代码库
- 现代: 活跃开发

**权衡**:
- ✅ 比 Electron 小 95%
- ✅ 更安全
- ⚠️ 较新（成熟度低）
- ⚠️ 构建需要 Rust 工具链

---

## 远程同步策略

### 决策: 基于 SSH 的元数据同步

**背景**: 用户在远程服务器训练，想在本地查看。

**考虑的替代方案**:
1. **完整 rsync**
   - 完整同步
   - 大数据集慢（小时）
   
2. **云存储**（S3, GCS）
   - 可扩展
   - 外部依赖，成本
   
3. **自定义协议**
   - 优化
   - 需要服务端守护进程
   
4. **数据库复制**
   - 高效
   - 复杂设置

**决策**: SSH + 仅元数据同步

**理由**:
- SSH: 通用，安全，无需特殊设置
- 仅元数据: 快速（MB vs GB）
- 按需下载: 用户控制带宽
- SFTP: 标准协议

**权衡**:
- ✅ 适用于任何 SSH 服务器
- ✅ 同步数据减少 99%
- ⚠️ 需要 SSH 访问
- ⚠️ 文件不立即可用（必须下载）

---

## 国际化

### 决策: i18next + 独立语言文件

**背景**: 支持中文和英文用户。

**考虑的替代方案**:
1. **硬编码字符串**
   - 简单
   - 无国际化
   
2. **gettext**（Python 标准）
   - Python 标准
   - React 中使用笨拙
   
3. **react-intl**
   - React 专用
   - 更冗长
   
4. **内联翻译**
   - 简单
   - 不可维护

**决策**: i18next + JSON 翻译文件

**理由**:
- 在 Python 和 React 中都能工作
- 成熟，支持良好
- 代码和翻译清晰分离
- 浏览器语言检测

**权衡**:
- ✅ 专业的国际化解决方案
- ✅ 易于添加语言
- ⚠️ 需要维护独立的翻译文件

---

## 为什么不...？

### 为什么不使用 TensorBoard 格式？

- TensorBoard: 可视化很好，管理较差
- Runicorn: 可视化 + 版本控制 + 协作
- TensorBoard 仍可并用

### 为什么不集成 W&B/MLflow？

- 焦点: 本地优先，隐私优先
- 复杂性: 集成增加依赖
- 理念: 自托管替代品，非扩展
- 未来: 可能添加导出到这些格式

### 为什么不用 GraphQL？

- REST: 更简单，更广泛理解
- FastAPI: 优秀的 REST 支持
- 复杂性: GraphQL 增加开销
- 未来: v0.5+ 可能添加 GraphQL 层

### 为什么不用微服务？

- 规模: 单机目标无益处
- 复杂性: 项目规模过度
- 部署: 复杂化用户设置
- 简单性: 单体更易开发和调试

---

## 经验教训

### 效果好的

1. **混合存储**: 性能 + 简单性平衡
2. **内容去重**: 大量空间节省，用户喜欢
3. **FastAPI**: 自动文档非常宝贵
4. **React + Ant Design**: 快速获得专业 UI

### 如果重来会改变

1. **更早的 V2 API**: 应该从一开始就用 SQLite
2. **更模块化**: 早期代码一些紧耦合
3. **测试**: 希望更早有更多集成测试

---

## 参考

实现细节请查看:
- [STORAGE_DESIGN.md](STORAGE_DESIGN.md) - 存储实现
- [API_DESIGN.md](API_DESIGN.md) - API 实现
- [COMPONENT_ARCHITECTURE.md](COMPONENT_ARCHITECTURE.md) - 组件细节

---

**返回**: [架构索引](README.md)


